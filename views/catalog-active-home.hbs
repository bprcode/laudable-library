{{! This template populates catalog-layout.hbs }}
{{#> catalog_layout no_back=1 no_title=1 stylesheet='/recent-carousel.css'}}{{#*inline 'content'~}}
<div class="dark-card">
    <div class="top-bar pb-4 pt-1 ps-3"><h1 class="serif">Welcome to the Catalog</h1></div>
    <div class="d-flex recent-outer">
        <div class="spotlight-pane">
            <div class="recently-added">
                <div class="recent-overlay serif"><h2 class="fw-semibold">Recently Added</h2></div>
                <div class="camera">
                    <!-- book model -->
                    <div class="book-model">
                        <div class="book-face book-front">
                            <div class="ambient-front"></div>
                            {{#each recent_books~}}
                            <!-- img crossorigin src="https://covers.openlibrary.org/b/id/{{cover_id}}-M.jpg" data-index="{{@index}}" class="covers" id="cover-{{@index}}" -->
                            <img crossorigin src="/{{cover_id}}-M.jpg" data-index="{{@index}}" class="covers" id="cover-{{@index}}">
                            {{~/each}}
                        </div>
                        <div class="book-face book-left"></div>
                        <div class="book-face book-right">
                            <div class="ambient-right"></div>
                        </div>
                        <div class="book-face book-top"></div>
                        <div class="ambient-before"></div>
                        <div class="blob-shadow"></div>
                    </div>
                    <!-- /book model -->
                </div>
            </div>
        </div>

        <!-- Cycling presentation text -->
        <div class="cycle-container">
            <div class="curtain-right"></div>
            <div class="d-flex cycle-text" id="cycle-id">
                <div class="current-pane pe-3" id="current-pane-id">
                    <h2 class="serif" id="current-title"></h2>
                    <p id="current-copy"></p>
                </div>
                <div class="next-pane pe-3" id="next-pane-id">
                    <h2 class="serif" id="next-title"></h2>
                    <p id="next-copy"></p>
                </div>
            </div>
        </div>
        <!-- /cycling presentation text -->

    </div>
</div>

<script>
const log = console.log.bind(console)
const qs = document.querySelector.bind(document)
const el = document.getElementById.bind(document)

const loadedImages = []
const spotlightData = [
    {{#each recent_books}}
    {
        title: `{{title}}`,
        snippet: abbreviateSnippet(`{{snippet}}`),
        cover_id: `{{cover_id}}`,
        book_url: `{{book_url}}`,
        index: `{{@index}}`
    },
    {{/each}}
]

const showTime = 8; // seconds for each animation cycle
document.documentElement.style.setProperty('--show-time', showTime + 's')

let loadsWaiting = spotlightData.length

function abbreviateSnippet (snippet) {
    const maxLength = 160
    const minLength = 80

    if (snippet.length <= maxLength) { return snippet }

    const maxedSlice = snippet.slice(0, maxLength)
    const coherentSlice = maxedSlice.match(/^.*\s/)[0] // Break on last space
    const firstSentence = snippet.match('^[^.]*\.')[0] // Break on last period

    if (firstSentence.length < maxLength
            && firstSentence.length > minLength) {
        return firstSentence
    }

    // Otherwise...
    return coherentSlice + '...'
}

function handleImageLoad(element) {

    loadedImages.push({
        element: element,
        aspect: element.width / element.height || 0.6,
        info: spotlightData[element.dataset.index]
    })

    // Sort descending based on template index
    // (which is itself based on serial index -- hence, newest first.)
    loadedImages.sort((a,b) => b.info.index - a.info.index)

    --loadsWaiting
    if (loadsWaiting < 1) {
        log('âš¡ All data loaded. Starting animations.')
        updateCover()
        setInterval(updateCover, showTime * 1000)
    }
}

for (const e of document.querySelectorAll('.covers')) {

    if (e.complete) {
        log(`ðŸ”¹ >> Already complete: ${e.id} from ${e.src}`)

        if (e.naturalHeight === 0) {
            log('ðŸ”º Complete, but invalid. naturalHeight is 0.')
            handleImageLoad(failover(e))

        } else {
            handleImageLoad(e)
        }

        continue
    }

    log(`>> not yet loaded: ${e.id} from ${e.src}`)

    // Create a replacement element with similar properties,
    // add it to the DOM, remove the previous element.
    function failover (element) {
        element.removeEventListener('load', reactToLoad)

        let div = document.createElement('div')
        div.textContent = spotlightData[element.dataset.index].title
        div.classList.add('covers', 'serif', 'fw-semibold', 'fs-5',
                            'bg-light', 'text-dark', 'text-break',
                            'overflow-hidden', 'mt-5', 'px-3', 'py-1',
                            'text-center')
        div.width = 180
        div.height = 300
        div.dataset.index = element.dataset.index
        div.style = 'max-height: 300px; --bs-bg-opacity: .6;'
                    + 'border-top: 8px solid #0008;'
                    + 'border-bottom: 8px solid #0008;'

        element.after(div)
        element.parentElement.removeChild(element)

        return div
    }

    function reactToLoad (event) {
        log(`ðŸ“— Load completed for ${e.id} from ${e.src}`)
        handleImageLoad(event.target)
    }

    e.addEventListener('load', reactToLoad)
    e.addEventListener('error', event => {
        log(`ðŸŸ¨ Error loading image element: ${e.id} from ${e.src}`)

        // Failover approach 1
        const replacement = failover(event.target)
        handleImageLoad(replacement)
    })
}

function restartAnimations () {

    qs('.camera').classList.remove('camera-animate')
    qs('.book-model').classList.remove('book-model-animate')
    qs('.book-front').classList.remove('book-front-animate')
    qs('.blob-shadow').classList.remove('blob-shadow-animate')
    el('cycle-id').classList.remove('cycle-forward-animate')
    void el('cycle-id').offsetWidth // Force reflow for animation restart

    qs('.camera').classList.add('camera-animate')
    qs('.book-model').classList.add('book-model-animate')
    qs('.book-front').classList.add('book-front-animate')
    qs('.blob-shadow').classList.add('blob-shadow-animate')
    el('cycle-id').classList.add('cycle-forward-animate')
}

function updateCover () {

    updateCover.counter ??= 0
    const image = loadedImages[updateCover.counter]
    const upcoming = loadedImages[(updateCover.counter + 1)
                                    % loadedImages.length]
    if (!image) {
        log('updateCover fired too soon. Aborting...')
        return
    }

    el('current-title').innerHTML = image.info.title
    el('current-copy').innerHTML = image.info.snippet
    el('next-title').innerHTML = upcoming.info.title
    el('next-copy').innerHTML = upcoming.info.snippet

    // Prepare to swap slides:
    setTimeout(() => {
        el('current-title').innerHTML = upcoming.info.title
        el('current-copy').innerHTML = upcoming.info.snippet
    }, showTime * 0.95 * 1000)

    document.querySelector('.recently-added').style.setProperty(
        '--book-aspect', image.aspect)
    
    for (const e of document.querySelectorAll('.covers')) {
        e.classList.add('d-none')
    }
    image.element.classList.remove('d-none')
    updateCover.counter++
    updateCover.counter %= loadedImages.length

    restartAnimations()
}

</script>
{{~/inline}}{{/catalog_layout}}
